diff --git a/docs/architecture/containers/dispatcher.md b/docs/architecture/containers/dispatcher.md
index 9d7ad34..72bfb4e 100644
--- a/docs/architecture/containers/dispatcher.md
+++ b/docs/architecture/containers/dispatcher.md
@@ -118,7 +118,7 @@ flowchart LR
 
 **Responsibilities:**
 - Route all upstream events to dependent jobs
-- Create tasks and enqueue to operator queues (SQS)
+- Create tasks and enqueue to operator queues (outbox → SQS)
 - Handle `runtime: dispatcher` jobs in-process (platform-only)
 - Monitor source job health (ECS workers with `activation: source`, `source.kind: always_on`)
 - Track in-flight jobs per operator (scaling control)
@@ -180,29 +180,20 @@ Dispatcher is stateless — durable state lives in Postgres. On failure/restart:
 - ECS restarts the service.
 - In-flight workers may continue executing their current attempt.
 - If a worker cannot heartbeat/report completion during the outage, it retries until the Dispatcher is reachable again.
-- Queued tasks are not lost: the enqueue reconciler will republish SQS wake-ups after restart.
+- Queued tasks are not lost: enqueue intents are persisted via the Postgres outbox and published after restart.
 
 Because execution is **at-least-once**, a long outage may cause some duplicate work (e.g., leases expire and tasks are retried). Output commits and routing are designed to be idempotent.
 
 ## SQS Queues
 
-Task dispatch mechanism for ECS workers.
+SQS carries only `{task_id}` wake-ups. Workers must **claim** tasks (leases) from the Dispatcher before executing; duplicates are expected and harmless.
 
-**Model:**
-- SQS carries a pointer (`task_id`) as a wake-up.
-- Workers must **claim** the task from the Dispatcher to acquire a lease before executing.
-- Duplicates are expected; leasing prevents concurrent execution.
+- Standard queue (FIFO is not required for correctness).
+- Workers extend message visibility for long tasks.
 
-**Why SQS (wake-up) + Postgres (source of truth):**
-- Efficient long-polling and ECS autoscaling integration.
-- Durable task state and retries live in Postgres, so lost/duplicated messages do not lose work.
+See [task_lifecycle.md](../task_lifecycle.md) for leasing, retries, and rehydration.
 
-**Configuration:**
-- Standard queue (FIFO is not required for correctness).
-- Visibility timeout: minutes (base), with worker-side visibility extension for long tasks.
-- DLQ for poison messages / repeated receive failures.
 
-See [task_lifecycle.md](../task_lifecycle.md) for leasing, visibility extension, and rehydration loops.
 
 ## Component View
 
diff --git a/docs/architecture/data_model/orchestration.md b/docs/architecture/data_model/orchestration.md
index ac0ea6c..4945135 100644
--- a/docs/architecture/data_model/orchestration.md
+++ b/docs/architecture/data_model/orchestration.md
@@ -237,13 +237,15 @@ Workers claim tasks via the Dispatcher. A claim is an atomic update:
 
 This prevents concurrent execution even if SQS delivers duplicates.
 
-### Outbox (Recommended)
+### Outbox (Required)
 
-To make SQS publishing and event routing **rehydratable**, the Dispatcher can use an outbox table.
+To make enqueueing and event routing **crash-safe** and **rehydratable**, the Dispatcher uses an outbox table.
 
-- Mutations (task completion, task creation, event acceptance) happen in Postgres transactions.
-- Side effects (send SQS messages, route events) are represented as outbox rows created in those same transactions.
-- A background worker drains the outbox and performs the side effects.
+**Rule:** any durable mutation in Postgres (state) that requires a side effect (enqueue to SQS, route an upstream event) must create an outbox row **in the same transaction**.
+
+- Task creation / retry → outbox `enqueue_task`
+- Event acceptance / task completion → outbox `route_event`
+- A background outbox worker drains `Pending` rows and performs the side effects.
 
 ```sql
 CREATE TABLE outbox (
@@ -263,7 +265,6 @@ CREATE INDEX idx_outbox_pending
     WHERE status = 'Pending';
 ```
 
-In v1, a simpler alternative is to scan `tasks` directly (enqueue reconciler) and skip an explicit outbox. The outbox is the more robust, testable pattern.
 
 ## Task Inputs
 
diff --git a/docs/architecture/event_flow.md b/docs/architecture/event_flow.md
index 9ba6704..fbd3837 100644
--- a/docs/architecture/event_flow.md
+++ b/docs/architecture/event_flow.md
@@ -47,6 +47,8 @@ sequenceDiagram
 
 **Notes:**
 
+- Dispatcher side effects (enqueue tasks, route events) are executed via the Postgres outbox worker; the diagram shows the logical effects.
+
 - SQS is treated as unordered at-least-once. Workers must claim tasks (leases) before running.
 - Workers extend SQS visibility for long tasks and heartbeat leases to Dispatcher.
 - For `replace` outputs to S3, workers write to a staging prefix and the Dispatcher commits the output (metadata) before routing events (see [data_versioning.md](data_versioning.md)).
diff --git a/docs/architecture/task_lifecycle.md b/docs/architecture/task_lifecycle.md
index d182be6..1730906 100644
--- a/docs/architecture/task_lifecycle.md
+++ b/docs/architecture/task_lifecycle.md
@@ -2,7 +2,7 @@
 
 This document defines the durable execution model for tasks: how tasks are created, claimed, retried, and recovered after failures.
 
-**Summary:** **Postgres (state)** is the source of truth. **SQS** is a wake-up mechanism.
+**Summary:** **Postgres (state)** is the source of truth. Side effects are recorded in an **outbox**. **SQS** is a wake-up mechanism.
 
 ## Guarantees
 
@@ -107,26 +107,28 @@ Retries are owned by the Dispatcher.
 - On failure or timeout, Dispatcher marks the task `Failed` and sets `next_retry_at` with backoff.
 - When the retry becomes eligible, Dispatcher transitions `Failed -> Queued`, increments `attempt`, and republishes a wake-up message.
 
-A retry does **not** create a new task row. It is a new attempt of the same `task_id`.
+A retry does **not** create a new task row.
 
-## Reconciliation Loops
+## Background Loops
 
-Two background loops make the system rehydratable:
+Three loops make the system rehydratable:
 
-1) **Enqueue reconciler**
-   - finds tasks in `Failed` with `next_retry_at <= now()` and makes them eligible for retry
-   - transitions `Failed -> Queued`, increments `attempt`, and publishes a new SQS wake-up
-   - also republish wake-ups for `Queued` tasks if the original SQS message was lost
+1) **Outbox worker**
+   - drains `outbox` rows created by Dispatcher transactions
+   - performs side effects: enqueue SQS wake-ups (`enqueue_task`) and route upstream events (`route_event`)
+   - on restart, resumes from `Pending` rows (no lost work)
 
-2) **Lease reaper**
-   - finds tasks in `Running` with `lease_expires_at < now()`
-   - marks them as timed out and schedules a retry (or marks terminal failure)
+2) **Retry scheduler**
+   - finds tasks eligible to retry (`status='Failed'` and `next_retry_at <= now()`)
+   - transitions them back to `Queued`, increments `attempt`, and writes an `enqueue_task` outbox row
+
+3) **Lease reaper**
+   - finds tasks with expired leases (`status='Running'` and `lease_expires_at < now()`)
+   - marks them timed out and schedules a retry (or terminal failure)
+
+If SQS drops a wake-up, the task is still durable in Postgres; it can be safely re-enqueued by writing another `enqueue_task` outbox row (leasing prevents concurrent execution).
 
-These loops ensure:
 
-- a crashed Dispatcher can restart and resume routing/enqueueing,
-- a lost SQS message does not lose the task,
-- a dead worker does not permanently block a task.
 
 ## Ordering
 
